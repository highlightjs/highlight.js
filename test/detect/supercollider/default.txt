/* Code examples */

// 60Hz Gabber Rave 1995
Server.default.boot;

(
SynthDef(\gabberkick, {
	var snd, freq, high, lfo;
	freq = \freq.kr(440) * (Env.perc(0.001, 0.08, curve: -1).ar * 48 * \bend.kr(1)).midiratio;
	snd = Saw.ar(freq);
	snd = (snd * 100).tanh + ((snd.sign - snd) * -8.dbamp);
	high = HPF.ar(snd, 300);
	lfo = SinOsc.ar(8, [0, 0.5pi]).range(0, 0.01);
	high = high.dup(2) + (DelayC.ar(high, 0.01, lfo) * -2.dbamp);
	snd = LPF.ar(snd, 100).dup(2) + high;
	snd = RLPF.ar(snd, 7000, 2);
	snd = BPeakEQ.ar(snd, \ffreq.kr(3000) * XLine.kr(1, 0.8, 0.3), 0.5, 15);
	snd = snd * Env.asr(0.001, 1, 0.05).ar(2, \gate.kr(1));
	Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;

SynthDef(\hoover, {
	var snd, freq, bw, delay, decay;
	freq = \freq.kr(440);
	freq = freq * Env([-5, 6, 0], [0.1, 1.7], [\lin, -4]).kr.midiratio;
	bw = 1.035;
	snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(20);
	snd = (Splay.ar(snd) * 3).atan;
	snd = snd * Env.asr(0.01, 1.0, 1.0).kr(0, \gate.kr(1));
	snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
	snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
	Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;
)

(
var durations;
durations = [1, 1, 1, 1, 3/4, 1/4, 1/2, 3/4, 1/4, 1/2];
Ppar([
	Pbind(*[
		instrument: \gabberkick,
		amp: -23.dbamp,
		freq: 60,
		legato: 0.8,
		ffreq: Pseq((0..(durations.size * 4 - 1)).normalize, inf).linexp(0, 1, 100, 4000),
		dur: Pseq(durations, inf),
		bend: Pfuncn({ |x| if(x < (1/2), 0.4, 1) }, inf) <> Pkey(\dur),
	]),
	Pbind(*[
		instrument: \hoover,
		amp: -20.dbamp,
		midinote: 74,
		dur: durations.sum * 2,
		sustain: 7,
	])
]).play(TempoClock(210 / 60));
)

/* Using environment variables */
~func = { |a| a.postln };
~eval = ~func.(3);

/* Example class file */
Foo : Bar {
	classvar a, b;
	var <>c, <d, >e;
	const f = 3, g = $a;

	*new { arg inC, inD, inE;
		^super.newCopyArgs(inC, inD, inE)
	}

	*fizz { |arg1, arg2|
		^arg1 * arg2 + a
	}

	buzz { |arg1, arg2|
		var var1 = [arg1, arg2, b].collect(_ + 4);
		^var1.collect(_.sqrt)
	}

	aMethod { ^thisMethod }
}

/* Core library excerpt */
SimpleNumber : Number {
	*new { ^this.shouldNotImplement(thisMethod) }
	isValidUGenInput { ^this.isNaN.not }
	numChannels { ^1 }
	magnitude { ^this.abs }
	angle { ^if(this >= 0) { 0.0 } { pi } }
	neg { _Neg; ^this.primitiveFailed }
	bitNot { _BitNot; ^this.primitiveFailed }
	/* ... */
}

